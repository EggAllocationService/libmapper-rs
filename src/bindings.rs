/* automatically generated by rust-bindgen 0.69.4 */
#![allow(warnings)]
#[repr(u32)]
#[doc = " Describes the possible data types used by libmapper."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_type {
    #[doc = "< Devices only."]
    MPR_DEV = 1,
    #[doc = "< Input signals."]
    MPR_SIG_IN = 2,
    #[doc = "< Output signals."]
    MPR_SIG_OUT = 4,
    #[doc = "< All signals."]
    MPR_SIG = 6,
    #[doc = "< Incoming maps."]
    MPR_MAP_IN = 8,
    #[doc = "< Outgoing maps."]
    MPR_MAP_OUT = 16,
    #[doc = "< All maps."]
    MPR_MAP = 24,
    #[doc = "< All objects: devs, sigs, maps."]
    MPR_OBJ = 31,
    #[doc = "< Object query."]
    MPR_LIST = 64,
    #[doc = "< Graph."]
    MPR_GRAPH = 65,
    #[doc = "< Boolean value."]
    MPR_BOOL = 98,
    #[doc = "< libmapper data type."]
    MPR_TYPE = 99,
    #[doc = "< 64-bit floating point."]
    MPR_DBL = 100,
    #[doc = "< 32-bit floating point."]
    MPR_FLT = 102,
    #[doc = "< 64-bit integer."]
    MPR_INT64 = 104,
    #[doc = "< 32-bit integer."]
    MPR_INT32 = 105,
    #[doc = "< String."]
    MPR_STR = 115,
    #[doc = "< 64-bit NTP timestamp."]
    MPR_TIME = 116,
    #[doc = "< pointer."]
    MPR_PTR = 118,
    #[doc = "< NULL value."]
    MPR_NULL = 78,
}
#[repr(u32)]
#[doc = " Symbolic representation of recognized properties."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_prop {
    MPR_PROP_UNKNOWN = 0,
    MPR_PROP_BUNDLE = 256,
    MPR_PROP_DATA = 512,
    MPR_PROP_DEV = 768,
    MPR_PROP_DIR = 1024,
    MPR_PROP_EPHEM = 1280,
    MPR_PROP_EXPR = 1536,
    MPR_PROP_HOST = 1792,
    MPR_PROP_ID = 2048,
    MPR_PROP_IS_LOCAL = 2304,
    MPR_PROP_JITTER = 2560,
    MPR_PROP_LEN = 2816,
    MPR_PROP_LIBVER = 3072,
    MPR_PROP_LINKED = 3328,
    MPR_PROP_MAX = 3584,
    MPR_PROP_MIN = 3840,
    MPR_PROP_MUTED = 4096,
    MPR_PROP_NAME = 4352,
    MPR_PROP_NUM_INST = 4608,
    MPR_PROP_NUM_MAPS = 4864,
    MPR_PROP_NUM_MAPS_IN = 5120,
    MPR_PROP_NUM_MAPS_OUT = 5376,
    MPR_PROP_NUM_SIGS_IN = 5632,
    MPR_PROP_NUM_SIGS_OUT = 5888,
    MPR_PROP_ORDINAL = 6144,
    MPR_PROP_PERIOD = 6400,
    MPR_PROP_PORT = 6656,
    MPR_PROP_PROCESS_LOC = 6912,
    MPR_PROP_PROTOCOL = 7168,
    MPR_PROP_RATE = 7424,
    MPR_PROP_SCOPE = 7680,
    MPR_PROP_SIG = 7936,
    MPR_PROP_SLOT = 8192,
    MPR_PROP_STATUS = 8448,
    MPR_PROP_STEAL_MODE = 8704,
    MPR_PROP_SYNCED = 8960,
    MPR_PROP_TYPE = 9216,
    MPR_PROP_UNIT = 9472,
    MPR_PROP_USE_INST = 9728,
    MPR_PROP_VERSION = 9984,
    MPR_PROP_EXTRA = 10240,
}
#[repr(u32)]
#[doc = " Possible operations for composing queries."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_op {
    MPR_OP_UNDEFINED = 0,
    #[doc = "< Property does not exist for this entity."]
    MPR_OP_NEX = 1,
    #[doc = "< Property value == query value."]
    MPR_OP_EQ = 2,
    #[doc = "< Property exists for this entity."]
    MPR_OP_EX = 3,
    #[doc = "< Property value > query value."]
    MPR_OP_GT = 4,
    #[doc = "< Property value >= query value"]
    MPR_OP_GTE = 5,
    #[doc = "< Property value < query value"]
    MPR_OP_LT = 6,
    #[doc = "< Property value <= query value"]
    MPR_OP_LTE = 7,
    #[doc = "< Property value != query value"]
    MPR_OP_NEQ = 8,
    #[doc = "< Applies to all elements of value"]
    MPR_OP_ALL = 16,
    #[doc = "< Applies to any element of value"]
    MPR_OP_ANY = 32,
    MPR_OP_NONE = 64,
}
#[repr(u32)]
#[doc = " Describes the possible endpoints of a map.\n  @ingroup map"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_loc {
    #[doc = "< Not yet defined"]
    MPR_LOC_UNDEFINED = 0,
    #[doc = "< Source signal(s) for this map."]
    MPR_LOC_SRC = 1,
    #[doc = "< Destination signal(s) for this map."]
    MPR_LOC_DST = 2,
    #[doc = "< Either source or destination signals."]
    MPR_LOC_ANY = 3,
    #[doc = "< Both source and destination signals."]
    MPR_LOC_BOTH = 7,
}
#[repr(u32)]
#[doc = " Describes the possible network protocol for map communication.\n  @ingroup map"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_proto {
    #[doc = "< Not yet defined"]
    MPR_PROTO_UNDEFINED = 0,
    #[doc = "< Map updates are sent using UDP."]
    MPR_PROTO_UDP = 1,
    #[doc = "< Map updates are sent using TCP."]
    MPR_PROTO_TCP = 2,
    MPR_NUM_PROTO = 3,
}
#[repr(u32)]
#[doc = " The set of possible directions for a signal.\n  @ingroup signal"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_dir {
    #[doc = "< Not yet defined."]
    MPR_DIR_UNDEFINED = 0,
    #[doc = "< Signal is an input"]
    MPR_DIR_IN = 1,
    #[doc = "< Signal is an output"]
    MPR_DIR_OUT = 2,
    #[doc = "< Either incoming or outgoing"]
    MPR_DIR_ANY = 3,
    #[doc = "< Both directions apply.  Currently signals\n   cannot be both inputs and outputs, so this\n   value is only used for querying device maps\n   that touch only local signals."]
    MPR_DIR_BOTH = 7,
}
#[repr(u32)]
#[doc = " The set of possible signal events, used to register and inform callbacks.\n  @ingroup signal"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_sig_evt {
    #[doc = "< New instance has been created."]
    MPR_SIG_INST_NEW = 1,
    #[doc = "< Instance was released upstream."]
    MPR_SIG_REL_UPSTRM = 2,
    #[doc = "< Instance was released downstream."]
    MPR_SIG_REL_DNSTRM = 4,
    #[doc = "< No local instances left."]
    MPR_SIG_INST_OFLW = 8,
    #[doc = "< Instance value has been updated."]
    MPR_SIG_UPDATE = 16,
    MPR_SIG_ALL = 31,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_sig_inst_status {
    #[doc = "< Instance value has been set remotely."]
    MPR_SIG_INST_SET_REMOTE = 0x0200,
    #[doc = "< Instance value has been set locally."]
    MPR_SIG_INST_SET_LOCAL = 0x0100,
    #[doc = "< Instance value has a value."]
    MPR_SIG_INST_HAS_VALUE = 0x0040,
    #[doc = "< Instance value has a value."]
    MPR_SIG_INST_IS_ACTIVE = 0x0020,
    #[doc = "< Instance value has changed since last checked"]
    MPR_STATUS_NEW_VALUE = 0x0080
}
#[repr(u32)]
#[doc = " Describes the voice-stealing mode for instances.\n  @ingroup map"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_steal_type {
    #[doc = "< No stealing will take place."]
    MPR_STEAL_NONE = 0,
    #[doc = "< Steal the oldest instance."]
    MPR_STEAL_OLDEST = 1,
    #[doc = "< Steal the newest instance."]
    MPR_STEAL_NEWEST = 2,
}
#[repr(u32)]
#[doc = " The set of possible graph events, used to inform callbacks.\n  @ingroup graph"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_graph_evt {
    #[doc = "< New record has been added to the graph."]
    MPR_OBJ_NEW = 0,
    #[doc = "< The existing record has been modified."]
    MPR_OBJ_MOD = 1,
    #[doc = "< The existing record has been removed."]
    MPR_OBJ_REM = 2,
    #[doc = "< The graph has lost contact with the remote entity."]
    MPR_OBJ_EXP = 3,
}
#[repr(u32)]
#[doc = " Describes the possible statuses for a libmapper object.\n  @ingroup object"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub enum mpr_status {
    MPR_STATUS_UNDEFINED = 0,
    MPR_STATUS_EXPIRED = 1,
    MPR_STATUS_STAGED = 2,
    MPR_STATUS_WAITING = 14,
    MPR_STATUS_READY = 54,
    MPR_STATUS_ACTIVE = 126,
    MPR_STATUS_RESERVED = 128,
    MPR_STATUS_ANY = 255,
}
#[doc = " Abstraction for accessing any object type."]
pub type mpr_obj = *mut ::std::os::raw::c_void;
#[doc = " An internal structure defining a device."]
pub type mpr_dev = *mut ::std::os::raw::c_void;
#[doc = " An internal structure defining a signal."]
pub type mpr_sig = *mut ::std::os::raw::c_void;
#[doc = " An internal structure defining a mapping between a set of signals."]
pub type mpr_map = *mut ::std::os::raw::c_void;
#[doc = " An internal structure defining a list of objects."]
pub type mpr_list = *mut *mut ::std::os::raw::c_void;
#[doc = " An internal structure representing the distributed mapping graph. */\n/*! This can be retrieved by calling mpr_obj_graph()."]
pub type mpr_graph = *mut ::std::os::raw::c_void;
#[doc = " An internal structure defining a grouping of signals."]
pub type mpr_sig_group = ::std::os::raw::c_int;
#[doc = " A 64-bit data structure containing an NTP-compatible time tag, as used by OSC."]
pub type mpr_time = ::std::os::raw::c_ulonglong;
#[doc = " This data structure must be large enough to hold a system pointer or a uin64_t"]
pub type mpr_id = ::std::os::raw::c_ulonglong;
#[doc = " A signal handler function can be called whenever a signal value changes.\n  \\param signal       The signal that has changed.\n  \\param event        The type of event that has occurred, e.g. `MPR_SIG_UPDATE` when the value has\n                      changed. Event types are listed in the enum `mpr_sig_evt` found in\n                      `mapper_constants.h`\n  \\param instance     The identifier of the instance that has been changed, if applicable.\n  \\param length       The array length of the current value in the case of `MPR_SIG_UPDATE`\n                      events, or `0` for other events.\n  \\param type         The data type of the signal.\n  \\param value        A pointer to the current value in the case of `MPR_SIG_UPDATE` events, or\n                      `NULL` for other events.\n  \\param time         The timetag associated with this event."]
pub type mpr_sig_handler = ::std::option::Option<
    unsafe extern "C" fn(
        signal: mpr_sig,
        event: mpr_sig_evt,
        instance: mpr_id,
        length: ::std::os::raw::c_int,
        type_: mpr_type,
        value: *const ::std::os::raw::c_void,
        time: mpr_time,
    ),
>;
#[doc = " A callback function prototype for when an object record is added or updated.\n  Such a function is passed in to `mpr_graph_add_cb()`.\n  \\param graph        The graph that registered this callback.\n  \\param object       The object record.\n  \\param event        A value of `mpr_graph_evt` indicating what is happening to the object record.\n  \\param data         The user context pointer registered with this callback."]
pub type mpr_graph_handler = ::std::option::Option<
    unsafe extern "C" fn(
        graph: mpr_graph,
        object: mpr_obj,
        event: mpr_graph_evt,
        data: *const ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " Return the internal `mpr_graph` structure used by an object.\n  \\param object       The object to query.\n  \\return             The `mpr_graph` used by this object."]
    pub fn mpr_obj_get_graph(object: mpr_obj) -> mpr_graph;
    #[doc = " Return the specific type of an object.\n  \\param object       The object to query.\n  \\return             The object type."]
    pub fn mpr_obj_get_type(object: mpr_obj) -> mpr_type;
    #[doc = " Get an object's number of properties.\n  \\param object       The object to check.\n  \\param staged       1 to include staged properties in the count, `0` otherwise.\n  \\return             The number of properties stored in the table."]
    pub fn mpr_obj_get_num_props(
        object: mpr_obj,
        staged: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = " Look up a property by index or one of the symbolic identifiers listed in `mpr_constants.h`.\n  \\param object       The object to check.\n  \\param index        Index or symbolic identifier of the property to retrieve.\n  \\param key          A pointer to a location to receive the name of the\n                      property value (Optional, pass `0` to ignore).\n  \\param length       A pointer to a location to receive the vector length of\n                      the property value (Optional, pass `0` to ignore).\n  \\param type         A pointer to a location to receive the type of the\n                      property value (Optional, pass `0` to ignore).\n  \\param value        A pointer to a location to receive the address of the\n                      property's value (Optional, pass `0` to ignore).\n  \\param published    A pointer to a location to receive the 'published' flag for this property\n                      (Optional, pass `0` to ignore).\n  \\return             Symbolic identifier of the retrieved property, or\n                      `MPR_PROP_UNKNOWN` if not found."]
    pub fn mpr_obj_get_prop_by_idx(
        object: mpr_obj,
        index: ::std::os::raw::c_int,
        key: *mut *const ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
        type_: *mut mpr_type,
        value: *mut *const ::std::os::raw::c_void,
        published: *mut ::std::os::raw::c_int,
    ) -> mpr_prop;
    #[doc = " Look up a property by name.\n  \\param object       The object to check.\n  \\param key          The name of the property to retrieve.\n  \\param length       A pointer to a location to receive the vector length of\n                      the property value (Optional, pass `0` to ignore).\n  \\param type         A pointer to a location to receive the type of the\n                      property value (Optional, pass `0` to ignore).\n  \\param value        A pointer to a location to receive the address of the\n                      property's value (Optional, pass `0` to ignore).\n  \\param published    A pointer to a location to receive the 'published' flag for this property\n                      (Optional, pass `0` to ignore).\n  \\return             Symbolic identifier of the retrieved property, or\n                      `MPR_PROP_UNKNOWN` if not found."]
    pub fn mpr_obj_get_prop_by_key(
        object: mpr_obj,
        key: *const ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
        type_: *mut mpr_type,
        value: *mut *const ::std::os::raw::c_void,
        published: *mut ::std::os::raw::c_int,
    ) -> mpr_prop;
    #[doc = " Look up a property by symbolic identifier or name and return as an integer if possible. Since\n  the returned value cannot represent a missing property it is recommended that this function\n  only be used to recover properties that are guaranteed to exist and have a compatible type.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'property'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property cast to integer type, or zero if the property does\n                      not exist or can't be cast to int."]
    pub fn mpr_obj_get_prop_as_int32(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Look up a property by symbolic identifier or name and return as an integer if possible. Since\n  the returned value cannot represent a missing property it is recommended that this function\n  only be used to recover properties that are guaranteed to exist and have a compatible type.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'property'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property cast to `int64_t` type, or zero if the property does\n                      not exist or can't be cast to `int64_t`."]
    pub fn mpr_obj_get_prop_as_int64(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_longlong;
    #[doc = " Look up a property by symbolic identifier or name and return as a float if possible. Since the\n  returned value cannot represent a missing property it is recommended that this function only be\n  used to recover properties that are guaranteed to exist and have a compatible type.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'property'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property cast to float type, or zero if the property does not\n                      exist or can't be cast to float."]
    pub fn mpr_obj_get_prop_as_flt(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> f32;
    #[doc = " Look up a property by symbolic identifier or name and return as a C string if possible.\n  The returned value belongs to the object and should not be freed.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'property'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property, or null if the property does not\n                      exist or has an incompatible type."]
    pub fn mpr_obj_get_prop_as_str(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
    #[doc = " Look up a property by symbolic identifier or name and return as a C pointer if possible.\n  The returned value belongs to the object and should not be freed.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'property'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property, or null if the property does not exist or has an\n                      incompatible type."]
    pub fn mpr_obj_get_prop_as_ptr(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_void;
    #[doc = " Look up a property by symbolic identifier or name and return as a `mpr_obj` if possible.\n  The returned value belongs to the object and should not be freed.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'property'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property, or null if the property does not exist or has an\n                      incompatible type."]
    pub fn mpr_obj_get_prop_as_obj(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> mpr_obj;
    #[doc = " Look up a property by symbolic identifier or name and return as a `mpr_list` if possible.\n  The returned value is a copy and can be safely modified (e.g. iterated) or freed.\n  \\param object       The object to check.\n  \\param property     The symbolic identifier of the property to recover. Can be set to\n                      `MPR_UNKNOWN` or `MPR_EXTRA` to specify the property by name instead.\n  \\param key          A string identifier (name) for the property. Only used if the 'proerty'\n                      argument is set to `MPR_UNKNOWN` or `MPR_EXTRA`.\n  \\return             Value of the property, or null if the property does not exist or has an\n                      incompatible type."]
    pub fn mpr_obj_get_prop_as_list(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> mpr_list;
    #[doc = " Set a property.  Can be used to provide arbitrary metadata. Value pointed to will be copied.\n  Properties can be specified by setting the 'property' argument to one of the symbolic\n  identifiers listed in `mpr_constants.h`; if 'property' is set to `MPR_PROP_UNKNOWN` or\n  `MPR_PROP_EXTRA` the 'name' argument will be used instead.\n  \\param object       The object to operate on.\n  \\param property     Symbolic identifier of the property to add.\n  \\param key          The name of the property to add.\n  \\param length       The length of value array.\n  \\param type         The property  datatype.\n  \\param value        An array of property values.\n  \\param publish      1 to publish to the distributed graph, `0` for local-only.\n  \\return             Symbolic identifier of the set property, or\n                      `MPR_PROP_UNKNOWN` if not found."]
    pub fn mpr_obj_set_prop(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        type_: mpr_type,
        value: *const ::std::os::raw::c_void,
        publish: ::std::os::raw::c_int,
    ) -> mpr_prop;
    #[doc = " Remove a property from an object.\n  \\param object       The object to operate on.\n  \\param property     Symbolic identifier of the property to remove.\n  \\param key          The name of the property to remove.\n  \\return             1 if property has been removed, `0` otherwise."]
    pub fn mpr_obj_remove_prop(
        object: mpr_obj,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Push any staged property changes out to the distributed graph.\n  \\param object       The object to operate on."]
    pub fn mpr_obj_push(object: mpr_obj);
    #[doc = " Helper to print the properties of an object.\n  \\param object       The object to print.\n  \\param staged       1 to print staged properties, `0` otherwise."]
    pub fn mpr_obj_print(object: mpr_obj, staged: ::std::os::raw::c_int);
    #[doc = " Allocate and initialize a device.\n  \\param name         A short descriptive string to identify the device. Must not contain spaces\n                      or the slash character '/'.\n  \\param graph        A previously allocated graph structure to use. If 0, one will be allocated\n                      for use with this device.\n  \\return             A newly allocated device.  Should be freed using `mpr_dev_free()`."]
    pub fn mpr_dev_new(name: *const ::std::os::raw::c_char, graph: mpr_graph) -> mpr_dev;
    #[doc = " Remove a device from the graph and free its resources.\n  \\param device       The device to free."]
    pub fn mpr_dev_free(device: mpr_dev);
    #[doc = " Return a unique identifier associated with a given device.\n  \\param device       The device to use.\n  \\return             A new unique id."]
    pub fn mpr_dev_generate_unique_id(device: mpr_dev) -> mpr_id;
    #[doc = " Return the list of signals for a given device.\n  \\param device       The device to query.\n  \\param direction    The direction of the signals to return, should be `MPR_DIR_IN`,\n                      `MPR_DIR_OUT`, or `MPR_DIR_ANY`.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_dev_get_sigs(device: mpr_dev, direction: mpr_dir) -> mpr_list;
    #[doc = " Return the list of maps for a given device.\n  \\param device       The device to query.\n  \\param direction    The direction of the maps to return, should be `MPR_DIR_IN`,\n                      `MPR_DIR_OUT`, or `MPR_DIR_ANY`.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_dev_get_maps(device: mpr_dev, direction: mpr_dir) -> mpr_list;
    #[doc = " Poll this device for new messages.  Note, if you have multiple devices, the right thing to do\n  is call this function for each of them with `block_ms=0`, and add your own sleep if necessary.\n  \\param device       The device to check messages for.\n  \\param block_ms     Number of milliseconds to block waiting for messages, or `0` for\n                      non-blocking behaviour.\n  \\return             The number of handled messages. May be zero if there was nothing to do."]
    pub fn mpr_dev_poll(device: mpr_dev, block_ms: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    #[doc = " Start automatically polling this device for new messages in a separate thread.\n  \\param device       The device to check messages for.\n  \\return             Zero if successful, less than zero otherwise."]
    pub fn mpr_dev_start_polling(device: mpr_dev) -> ::std::os::raw::c_int;
    #[doc = " Stop automatically polling this device for new messages in a separate thread.\n  \\param device       The device to check messages for.\n  \\return             Zero if successful, less than zero otherwise."]
    pub fn mpr_dev_stop_polling(device: mpr_dev) -> ::std::os::raw::c_int;
    #[doc = " Detect whether a device is completely initialized.\n  \\param device       The device to query.\n  \\return             Non-zero if device is completely initialized, i.e., has an allocated\n                      receiving port and unique identifier. Zero otherwise."]
    pub fn mpr_dev_get_is_ready(device: mpr_dev) -> ::std::os::raw::c_int;
    #[doc = " Get the current time for a device.\n  \\param device       The device to use.\n  \\return             The current time."]
    pub fn mpr_dev_get_time(device: mpr_dev) -> mpr_time;
    #[doc = " Set the time for a device. Use only if user code has access to a more accurate\n  timestamp than the operating system.\n  \\param device       The device to use.\n  \\param time         The time to set. This time will be used for tagging signal updates until\n                      the next occurrence `mpr_dev_set_time()` or `mpr_dev_poll()`."]
    pub fn mpr_dev_set_time(device: mpr_dev, time: mpr_time);
    #[doc = " Trigger map propagation for a given timestep. This function can be omitted if `mpr_dev_poll()`\n  is called each sampling timestep, however calling `mpr_dev_poll()` at a lower rate may be more\n  performant.\n  \\param device       The device to use."]
    pub fn mpr_dev_update_maps(device: mpr_dev);
    #[doc = " Allocate and initialize a signal.  Values and strings pointed to by this call will be copied.\n  For minimum and maximum values, type must match 'type' (if `type=MPR_INT32`, then `int*`, etc)\n  and length must match 'length' (i.e. a scalar if `length=1`, or an array with `length` elements).\n  \\param parent           The object to add a signal to.\n  \\param direction    \tThe signal direction.\n  \\param name             The name of the signal.\n  \\param length           The length of the signal vector, or `1` for a scalar.\n  \\param type             The type of the signal value.\n  \\param unit             The unit of the signal, or `NULL` for none.\n  \\param minimum          Pointer to a minimum value, or `NULL` for none.\n  \\param maximum          Pointer to a maximum value, or `NULL` for none.\n  \\param num_instances    Pointer to the number of signal instances, or `NULL` to indicate that\n                          instances will not be used.\n  \\param handler          Function to be called when the signal is updated, or `NULL` for none.\n  \\param events           Bitflags for types of events that should trigger the handler. Event\n                          types are listed in the enum `mpr_sig_evt` found in `mapper_constants.h`\n  \\return                 The new signal."]
    pub fn mpr_sig_new(
        parent: mpr_dev,
        direction: mpr_dir,
        name: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        type_: mpr_type,
        unit: *const ::std::os::raw::c_char,
        minimum: *const ::std::os::raw::c_void,
        maximum: *const ::std::os::raw::c_void,
        num_instances: *mut ::std::os::raw::c_int,
        handler: mpr_sig_handler,
        events: ::std::os::raw::c_int,
    ) -> mpr_sig;
    pub fn mpr_sig_free(signal: mpr_sig);
    #[doc = " Update the value of a signal instance.  The signal will be routed according\n  to external requests.\n  \\param signal       The signal to operate on.\n  \\param instance     A pointer to the identifier of the instance to update,\n                      or `0` for the default instance.\n  \\param length       Length of the value argument. Expected to be equal to the signal length.\n  \\param type         Data type of the value argument.\n  \\param value        A pointer to a new value for this signal.  If the `type` argument is\n                      `MPR_INT32`, this should be `int*`; if the type argument is `MPR_FLOAT`,\n                      this should be `float*` (etc).  It should be an array at least as long as\n                      the `length` argument."]
    pub fn mpr_sig_set_value(
        signal: mpr_sig,
        instance: mpr_id,
        length: ::std::os::raw::c_int,
        type_: mpr_type,
        value: *const ::std::os::raw::c_void,
    );
    #[doc = " Get the value of a signal instance.\n  \\param signal       The signal to operate on.\n  \\param instance     A pointer to the identifier of the instance to query,\n                      or `0` for the default instance.\n  \\param time         A location to receive the value's time tag (Optional, pass `0` to ignore).\n  \\return             A pointer to an array containing the value of the signal\n                      instance, or `0` if the signal instance has no value."]
    pub fn mpr_sig_get_value(
        signal: mpr_sig,
        instance: mpr_id,
        time: *mut mpr_time,
    ) -> *const ::std::os::raw::c_void;
    #[doc = " Return the list of maps associated with a given signal.\n  \\param signal       Signal record to query for maps.\n  \\param direction    The direction of the map relative to the given signal.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_sig_get_maps(signal: mpr_sig, direction: mpr_dir) -> mpr_list;
    #[doc = " Get the parent `mpr_dev` for a specific signal.\n  \\param signal       The signal to check.\n  \\return             The signal's parent device."]
    pub fn mpr_sig_get_dev(signal: mpr_sig) -> mpr_dev;
    #[doc = " Set or unset the message handler for a signal.\n  \\param signal       The signal to operate on.\n  \\param handler      A pointer to a `mpr_sig_handler` function for processing incoming messages.\n  \\param events       Bitflags for types of events we are interested in. Event types are listed\n                      in the enum `mpr_sig_evt` found in `mapper_constants.h`"]
    pub fn mpr_sig_set_cb(signal: mpr_sig, handler: mpr_sig_handler, events: ::std::os::raw::c_int);
    #[doc = " Allocate new instances and add them to the reserve list. Note that if instance ids are\n  specified, libmapper will not add multiple instances with the same id.\n  \\param signal       The signal to which the instances will be added.\n  \\param number       The number of instances to add.\n  \\param ids          Array of integer ids, one for each new instance,\n                      or `0` for automatically-generated instance ids.\n  \\param data         Array of user context pointers, one for each new instance,\n                      or `0` if not needed.\n  \\return             Number of instances added."]
    pub fn mpr_sig_reserve_inst(
        signal: mpr_sig,
        number: ::std::os::raw::c_int,
        ids: *mut mpr_id,
        data: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    #[doc = " Release a specific instance of a signal by removing it from the list of\n  active instances and adding it to the reserve list.\n  \\param signal       The signal to operate on.\n  \\param instance     The identifier of the instance to suspend."]
    pub fn mpr_sig_release_inst(signal: mpr_sig, instance: mpr_id);
    #[doc = " Remove a specific instance of a signal and free its memory.\n  \\param signal       The signal to operate on.\n  \\param instance     The identifier of the instance to suspend."]
    pub fn mpr_sig_remove_inst(signal: mpr_sig, instance: mpr_id);
    #[doc = " Return whether a given signal instance is currently active.\n  \\param signal       The signal to operate on.\n  \\param instance     The identifier of the instance to check.\n  \\return             Non-zero if the instance is active, zero otherwise."]
    pub fn mpr_sig_get_inst_is_active(signal: mpr_sig, instance: mpr_id) -> ::std::os::raw::c_int;
    #[doc = " Activate a specific signal instance without setting it's value. In general it is not necessary\n  to use this function, since signal instances will be automatically activated as necessary when\n  signals are updated by `mpr_sig_set_value()` or through a map.\n  \\param signal       The signal to operate on.\n  \\param instance     The identifier of the instance to activate.\n  \\return             Non-zero if the instance is active, zero otherwise."]
    pub fn mpr_sig_activate_inst(signal: mpr_sig, instance: mpr_id) -> ::std::os::raw::c_int;
    #[doc = " Get the local identifier of the oldest active instance.\n  \\param signal       The signal to operate on.\n  \\return             The instance identifier, or zero if unsuccessful."]
    pub fn mpr_sig_get_oldest_inst_id(signal: mpr_sig) -> mpr_id;
    #[doc = " Get the local identifier of the newest active instance.\n  \\param signal       The signal to operate on.\n  \\return             The instance identifier, or zero if unsuccessful."]
    pub fn mpr_sig_get_newest_inst_id(signal: mpr_sig) -> mpr_id;
    #[doc = " Get a signal instance's identifier by its index.  Intended to be used for\n  iterating over the active instances.\n  \\param signal       The signal to operate on.\n  \\param index        The numerical index of the instance to retrieve.  Should be between zero\n                      and the number of instances.\n  \\param status       The status of the instances to search should be set to `MPR_STATUS_ACTIVE`,\n                      `MPR_STATUS_RESERVED`, or both (`MPR_STATUS_ACTIVE | MPR_STATUS_RESERVED`).\n  \\return             The instance identifier associated with the given index, or zero\n                      if unsuccessful."]
    pub fn mpr_sig_get_inst_id(
        signal: mpr_sig,
        index: ::std::os::raw::c_int,
        status: mpr_status,
    ) -> mpr_id;
    #[doc = " Associate a signal instance with an arbitrary pointer.\n  \\param signal       The signal to operate on.\n  \\param instance     The identifier of the instance to operate on.\n  \\param data         A pointer to user data to be associated with this instance."]
    pub fn mpr_sig_set_inst_data(
        signal: mpr_sig,
        instance: mpr_id,
        data: *const ::std::os::raw::c_void,
    );
    #[doc = " Retrieve the arbitrary pointer associated with a signal instance.\n  \\param signal       The signal to operate on.\n  \\param instance     The identifier of the instance to operate on.\n  \\return             A pointer associated with this instance."]
    pub fn mpr_sig_get_inst_data(signal: mpr_sig, instance: mpr_id) -> *mut ::std::os::raw::c_void;
    #[doc = " Get the number of instances for a specific signal.\n  \\param signal       The signal to check.\n  \\param status       The status of the instances to search should be set to `MPR_STATUS_ACTIVE`,\n                      `MPR_STATUS_RESERVED`, or both (`MPR_STATUS_ACTIVE | MPR_STATUS_RESERVED`).\n  \\return             The number of allocated signal instances matching the specified status."]
    pub fn mpr_sig_get_num_inst(signal: mpr_sig, status: mpr_status) -> ::std::os::raw::c_int;
    #[doc = " Get the status of a signal instance.\n  \\param signal       The signal to check.\n  \\param instance     The identifier of the instance to check.\n  \\return             The status of the signal instance returned as bitflags. Test the return\n                      value against the constants defined in the enum `mpr_sig_inst_status`"]
    pub fn mpr_sig_get_inst_status(arg1: mpr_sig, instance: mpr_id) -> ::std::os::raw::c_int;
    #[doc = " Create a map between a set of signals. The map will not take effect until it\n  has been added to the distributed graph using `mpr_obj_push()`.\n  \\param num_sources      The number of source signals in this map.\n  \\param sources          Array of source signal data structures.\n  \\param num_destinations The number of destination signals in this map.\n                          Currently restricted to `1`.\n  \\param destinations     Array of destination signal data structures.\n  \\return                 A map data structure – either loaded from the graph (if the map already\n                          existed) or newly created. In the latter case the map will not take\n                          effect until it has been added to the distributed graph using\n                          `mpr_obj_push()`."]
    pub fn mpr_map_new(
        num_sources: ::std::os::raw::c_int,
        sources: *const mpr_sig,
        num_destinations: ::std::os::raw::c_int,
        destinations: *const mpr_sig,
    ) -> mpr_map;
    #[doc = " Create a map between a set of signals using an expression string containing embedded format\n  specifiers that are replaced by `mpr_sig` values specified in subsequent additional arguments.\n  The map will not take effect until it has been added to the distributed graph using\n  `mpr_obj_push()`.\n  \\param expression   A string specifying the map expression to use when mapping source to\n                      destination signals. The format specifier \"%x\" is used to specify source\n                      signals and the \"%y\" is used to specify the destination signal.\n  \\param ...          A sequence of additional `mpr_sig` arguments, one for each format specifier\n                      in the format string\n  \\return             A map data structure – either loaded from the graph (if the map already\n                      existed) or newly created. Changes to the map will not take effect until it\n                      has been added to the distributed graph using `mpr_obj_push()`."]
    pub fn mpr_map_new_from_str(expression: *const ::std::os::raw::c_char, ...) -> mpr_map;
    #[doc = " Remove a map between a set of signals.\n  \\param map          The map to destroy."]
    pub fn mpr_map_release(map: mpr_map);
    #[doc = " Retrieve a list of connected signals for a specific map.\n  \\param map          The map to check.\n  \\param endpoint     The map endpoint, must be `MPR_LOC_SRC`, `MPR_LOC_DST`, or `MPR_LOC_ANY`.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_map_get_sigs(map: mpr_map, endpoint: mpr_loc) -> mpr_list;
    #[doc = " Retrieve the index for a specific map signal.\n  \\param map          The map to check.\n  \\param signal       The signal to find.\n  \\return             The signal index, or `-1` if not found."]
    pub fn mpr_map_get_sig_idx(map: mpr_map, signal: mpr_sig) -> ::std::os::raw::c_int;
    #[doc = " Detect whether a map is completely initialized.\n  \\param map          The device to query.\n  \\return             Non-zero if map is completely initialized, zero otherwise."]
    pub fn mpr_map_get_is_ready(map: mpr_map) -> ::std::os::raw::c_int;
    #[doc = " Re-create stale map if necessary.\n  \\param map          The map to operate on."]
    pub fn mpr_map_refresh(map: mpr_map);
    #[doc = " Add a scope to this map. Map scopes configure the propagation of signal instance updates across\n  the map. Changes to remote maps will not take effect until synchronized with the distributed\n  graph using `mpr_obj_push()`.\n  \\param map          The map to modify.\n  \\param device       Device to add as a scope for this map. After taking effect, this setting\n                      will cause instance updates originating at this device to be propagated\n                      across the map."]
    pub fn mpr_map_add_scope(map: mpr_map, device: mpr_dev);
    #[doc = " Remove a scope from this map. Map scopes configure the propagation of signal instance updates\n  across the map. Changes to remote maps will not take effect until synchronized with the\n  distributed graph using `mpr_obj_push()`.\n  \\param map          The map to modify.\n  \\param device       Device to remove as a scope for this map. After taking effect, this setting\n                      will cause instance updates originating at this device to be blocked from\n                      propagating across the map."]
    pub fn mpr_map_remove_scope(map: mpr_map, device: mpr_dev);
    #[doc = " Filter a list of objects using the given property.\n  \\param list         The list of objects to filter.\n  \\param property     Symbolic identifier of the property to look for.\n  \\param key          The name of the property to search for.\n  \\param length       The value length.\n  \\param type         The value type. Comparisons for object types (MPR_OBJ, MPR_DEV, etc.) are\n                      performed using the object id and therefore should only be used when\n                      filtering registered objects (e.g. remote objects stored in the graph or\n                      local objects that have completed registration). This means that duplicate\n                      representations of the same object stored in different graphs will be equal.\n                      If comparison of local object representations is desired use the MPR_PTR\n                      type instead.\n  \\param value        The value.\n  \\param op           The comparison operator.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_list_filter(
        list: mpr_list,
        property: mpr_prop,
        key: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_int,
        type_: mpr_type,
        value: *const ::std::os::raw::c_void,
        op: mpr_op,
    ) -> mpr_list;
    #[doc = " Get the union of two object lists (objects matching list1 OR list2).\n  \\param list1        The first object list.\n  \\param list2        The second object list.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_list_get_union(list1: mpr_list, list2: mpr_list) -> mpr_list;
    #[doc = " Get the intersection of two object lists (objects matching list1 AND list2).\n  \\param list1        The first object list.\n  \\param list2        The second object list.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_list_get_isect(list1: mpr_list, list2: mpr_list) -> mpr_list;
    #[doc = " Get the difference between two object lists (objects in list1 but NOT list2).\n  \\param list1        The first object list.\n  \\param list2        The second object list.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_list_get_diff(list1: mpr_list, list2: mpr_list) -> mpr_list;
    #[doc = " Get an indexed item in a list of objects.\n  \\param list         The object list to query.\n  \\param index        The index of the list element to retrieve.\n  \\return             A pointer to the object record, or zero if it doesn't exist."]
    pub fn mpr_list_get_idx(list: mpr_list, index: ::std::os::raw::c_uint) -> mpr_obj;
    #[doc = " Given an object list returned from a previous object query, get the next item.\n  \\param list         The object list to query.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_list_get_next(list: mpr_list) -> mpr_list;
    #[doc = " Copy a previously-constructed object list.\n  \\param list         The object list to copy.\n  \\return             A copy of the initial list.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_list_get_cpy(list: mpr_list) -> mpr_list;
    #[doc = " Given an object list returned from a previous object query,\n  indicate that we are done iterating.\n  \\param list         The object list to free."]
    pub fn mpr_list_free(list: mpr_list);
    #[doc = " Return the number of objects in a previous object query list.\n  \\param list         The object list to query.\n  \\return             The number of objects in the list."]
    pub fn mpr_list_get_size(list: mpr_list) -> ::std::os::raw::c_int;
    #[doc = " Print the contents of an object list returned from a previous object query.\n  \\param list         The object list to print."]
    pub fn mpr_list_print(list: mpr_list);
    #[doc = " Create a peer in the distributed graph.\n  \\param autosubscribe_types  A combination of `mpr_type` values controlling whether the graph\n                              should automatically subscribe to information about devices,\n                              signals and/or maps when it encounters a previously-unseen device.\n  \\return                     The new graph."]
    pub fn mpr_graph_new(autosubscribe_types: ::std::os::raw::c_int) -> mpr_graph;
    #[doc = " Specify network interface to use.\n  \\param graph        The graph structure to use.\n  \\param iface        The name of the network interface to use.\n  \\return             Zero if successful, non-zero otherwise."]
    pub fn mpr_graph_set_interface(
        graph: mpr_graph,
        iface: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
    #[doc = " Return a string indicating the name of the network interface in use.\n  The returned value belongs to the graph and should not be modified or freed.\n  \\param graph        The graph structure to query.\n  \\return             A string containing the name of the network interface."]
    pub fn mpr_graph_get_interface(graph: mpr_graph) -> *const ::std::os::raw::c_char;
    #[doc = " Set the multicast group and port to use.\n  \\param graph        The graph structure to query.\n  \\param group        A string specifying the multicast group for bus communication with the\n                      distributed graph.\n  \\param port         The port to use for multicast communication.\n  \\return             Zero if successful, non-zero otherwise."]
    pub fn mpr_graph_set_address(
        graph: mpr_graph,
        group: *const ::std::os::raw::c_char,
        port: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = " Retrieve the multicast group currently in use.\n  The returned value belongs to the graph and should not be modified or freed.\n  \\param graph        The graph structure to query.\n  \\return             A string specifying the multicast URL for bus communication with the\n                      distributed graph."]
    pub fn mpr_graph_get_address(graph: mpr_graph) -> *const ::std::os::raw::c_char;
    #[doc = " Synchronize a local graph copy with the distributed graph.\n  \\param graph        The graph to update.\n  \\param block_ms     The number of milliseconds to block, or `0` for non-blocking behaviour.\n  \\return             The number of handled messages."]
    pub fn mpr_graph_poll(
        graph: mpr_graph,
        block_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
    #[doc = " Start automatically synchronizing a local graph copy in a separate thread.\n  \\param graph        The graph to update.\n  \\return             Zero if successful, less than zero otherwise."]
    pub fn mpr_graph_start_polling(graph: mpr_graph) -> ::std::os::raw::c_int;
    #[doc = " Stop automatically synchronizing a local graph copy in a separate thread.\n  \\param graph        The graph to update.\n  \\return             Zero if successful, less than zero otherwise."]
    pub fn mpr_graph_stop_polling(graph: mpr_graph) -> ::std::os::raw::c_int;
    #[doc = " Free a graph.\n  \\param graph        The graph to free."]
    pub fn mpr_graph_free(graph: mpr_graph);
    #[doc = " Subscribe to receive information from remote objects.\n  \\param graph        The graph to use.\n  \\param device       The device of interest. If `NULL` the graph will automatically subscribe to\n                      all discovered devices.\n  \\param types        Bitflags setting the type of information of interest.\n                      Can be a combination of `mpr_type` values.\n  \\param timeout      The length in seconds for this subscription. If set to `-1`, the graph will\n                      automatically renew the subscription until it is freed or this function is\n                      called again."]
    pub fn mpr_graph_subscribe(
        graph: mpr_graph,
        device: mpr_dev,
        types: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    );
    #[doc = " Unsubscribe from information from remote objects.\n  \\param graph        The graph to use.\n  \\param device       The device of interest. If NULL the graph will\n                      unsubscribe from all devices."]
    pub fn mpr_graph_unsubscribe(graph: mpr_graph, device: mpr_dev);
    #[doc = " Register a callback for when an object record is added or updated in the graph.\n  \\param graph        The graph to query.\n  \\param handler      Callback function.\n  \\param types        Bitflags setting the type of information of interest.\n                      Can be a combination of `mpr_type` values.\n  \\param data         A user-defined pointer to be passed to the callback for context.\n  \\return             One if a callback was added, otherwise zero."]
    pub fn mpr_graph_add_cb(
        graph: mpr_graph,
        handler: mpr_graph_handler,
        types: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
    #[doc = " Remove an object record callback from the graph service.\n  \\param graph        The graph to query.\n  \\param handler      Callback function.\n  \\param data         The user context pointer that was originally specified\n                      when adding the callback.\n  \\return             User data pointer associated with this callback (if any)."]
    pub fn mpr_graph_remove_cb(
        graph: mpr_graph,
        handler: mpr_graph_handler,
        data: *const ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
    #[doc = " Return a list of objects.\n  \\param graph        The graph to query.\n  \\param types        Bitflags setting the type of information of interest. Currently restricted\n                      to a single object type.\n  \\return             A list of results.  Use `mpr_list_get_next()` to iterate."]
    pub fn mpr_graph_get_list(graph: mpr_graph, types: ::std::os::raw::c_int) -> mpr_list;
    #[doc = " Retrieve a specific object from the graph by id.\n  \\param graph        The graph to query.\n  \\param type         The type of object to search for. Use `MPR_OBJ` if the type is not known.\n  \\param id           Unique id identifying the object to find in the graph.\n  \\return             The object matching the query, or zero if not found."]
    pub fn mpr_graph_get_obj(graph: mpr_graph, id: mpr_id, type_: mpr_type) -> mpr_obj;
    #[doc = " Add a time to another given time.\n  \\param augend       A previously allocated time to augment.\n  \\param addend       A time to add."]
    pub fn mpr_time_add(augend: *mut mpr_time, addend: mpr_time);
    #[doc = " Add a double-precision floating point value to another given time.\n  \\param augend       A previously allocated time to augment.\n  \\param addend       A value in seconds to add."]
    pub fn mpr_time_add_dbl(augend: *mut mpr_time, addend: f64);
    #[doc = " Subtract a time from another given time.\n  \\param minuend      A previously allocated time to augment.\n  \\param subtrahend   A time to add to subtract."]
    pub fn mpr_time_sub(minuend: *mut mpr_time, subtrahend: mpr_time);
    #[doc = " Add a double-precision floating point value to another given time.\n  \\param time         A previously allocated time to multiply.\n  \\param multiplicand A value in seconds."]
    pub fn mpr_time_mul(time: *mut mpr_time, multiplicand: f64);
    #[doc = " Return value of a `mpr_time` as a double-precision floating point value.\n  \\param time         The time to read.\n  \\return             Value of the time as a double-precision float."]
    pub fn mpr_time_as_dbl(time: mpr_time) -> f64;
    #[doc = " Set value of a `mpr_time` from a double-precision floating point value.\n  \\param time         A previously-allocated time to set.\n  \\param value        The value in seconds to set."]
    pub fn mpr_time_set_dbl(time: *mut mpr_time, value: f64);
    #[doc = " Copy value of a `mpr_time`.\n  \\param timel        The target time for copying.\n  \\param timer        The source time."]
    pub fn mpr_time_set(timel: *mut mpr_time, timer: mpr_time);
    #[doc = " Compare two timetags, returning zero if they all match or a value different from zero\n  representing which is greater if they do not.\n  \\param time1        A previously allocated time to augment.\n  \\param time2        A time to add.\n  \\return             `<0` if `time1 < time2`; `0` if `time1 == time2`; `>0` if `time1 > time2`."]
    pub fn mpr_time_cmp(time1: mpr_time, time2: mpr_time) -> ::std::os::raw::c_int;
    #[doc = " Helper to print a libmapper timetag\n  \\param time         The timetag to print."]
    pub fn mpr_time_print(time: mpr_time);
    #[doc = " Get the version of libmapper.\n  \\return             A string specifying the version of libmapper."]
    pub fn mpr_get_version() -> *const ::std::os::raw::c_char;
}
